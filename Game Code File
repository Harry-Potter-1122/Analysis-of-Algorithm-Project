// Code Generated by ChatGPT
#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <cmath>

const int WIDTH = 800;
const int HEIGHT = 600;
const int NUM_OBJECTS = 100;
const int CAPACITY = 4;

struct Point {
    float x, y;
    Point(float x = 0, float y = 0) : x(x), y(y) {}
};

struct GameObject {
    Point pos;
    float radius;
    GameObject(float x, float y, float r) : pos(x, y), radius(r) {}
};

struct Boundary {
    float x, y, w, h;
    Boundary(float x, float y, float w, float h) : x(x), y(y), w(w), h(h) {}

    bool contains(const GameObject& obj) const {
        return (obj.pos.x >= x - w && obj.pos.x <= x + w &&
                obj.pos.y >= y - h && obj.pos.y <= y + h);
    }

    bool intersects(const Boundary& range) const {
        return !(range.x - range.w > x + w ||
                 range.x + range.w < x - w ||
                 range.y - range.h > y + h ||
                 range.y + range.h < y - h);
    }
};

class Quadtree {
    Boundary boundary;
    std::vector<GameObject*> objects;
    bool divided = false;

    Quadtree *nw = nullptr;
    Quadtree *ne = nullptr;
    Quadtree *sw = nullptr;
    Quadtree *se = nullptr;

public:
    Quadtree(Boundary boundary) : boundary(boundary) {}

    ~Quadtree() {
        delete nw; delete ne; delete sw; delete se;
    }

    void subdivide() {
        float x = boundary.x, y = boundary.y;
        float w = boundary.w / 2, h = boundary.h / 2;
        nw = new Quadtree(Boundary(x - w, y - h, w, h));
        ne = new Quadtree(Boundary(x + w, y - h, w, h));
        sw = new Quadtree(Boundary(x - w, y + h, w, h));
        se = new Quadtree(Boundary(x + w, y + h, w, h));
        divided = true;
    }

    bool insert(GameObject* obj) {
        if (!boundary.contains(*obj)) return false;

        if (objects.size() < CAPACITY) {
            objects.push_back(obj);
            return true;
        }

        if (!divided) subdivide();

        return nw->insert(obj) || ne->insert(obj) ||
               sw->insert(obj) || se->insert(obj);
    }

    void query(const Boundary& range, std::vector<GameObject*>& found) {
        if (!boundary.intersects(range)) return;

        for (auto* obj : objects) {
            if (range.contains(*obj)) found.push_back(obj);
        }

        if (divided) {
            nw->query(range, found);
            ne->query(range, found);
            sw->query(range, found);
            se->query(range, found);
        }
    }
};

bool checkCollision(const GameObject& a, const GameObject& b) {
    float dx = a.pos.x - b.pos.x;
    float dy = a.pos.y - b.pos.y;
    float distance = std::sqrt(dx*dx + dy*dy);
    return distance < (a.radius + b.radius);
}

int main() {
    srand(time(nullptr));

    // Player
    GameObject player(WIDTH / 2, HEIGHT / 2, 10);

    // Random game objects
    std::vector<GameObject> objects;
    for (int i = 0; i < NUM_OBJECTS; i++) {
        float x = rand() % WIDTH;
        float y = rand() % HEIGHT;
        objects.emplace_back(x, y, 5);
    }

    // Create Quadtree
    Quadtree tree(Boundary(WIDTH / 2, HEIGHT / 2, WIDTH / 2, HEIGHT / 2));

    // Insert objects into Quadtree
    for (auto& obj : objects) {
        tree.insert(&obj);
    }

    // Define player detection range
    Boundary detectionRange(player.pos.x, player.pos.y, 50, 50);
    std::vector<GameObject*> possibleCollisions;
    tree.query(detectionRange, possibleCollisions);

    // Check for real collisions
    std::cout << "Objects potentially colliding with player: " << possibleCollisions.size() << "\n";
    for (GameObject* obj : possibleCollisions) {
        if (checkCollision(player, *obj)) {
            std::cout << "Collision detected at (" << obj->pos.x << ", " << obj->pos.y << ")\n";
        }
    }

    return 0;
}
